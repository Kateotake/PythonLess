# def f(x):
#     return x**2

# g = f # кладем в ПЕРЕМЕННУЮ нашу функцию f

# print(type(f))
# print(type(g))
# # они будут одинаковые

# print(f(4))
# print (g(4))
# # они будут одинаковые

# def calc1(x):
#     return x+10

# def calc2(x):
#     return x*10


# def math (op, x):  # функция на вход принимает ФУНКЦИЮ op
#     print(op(x))

# math(calc1, 10)
# math(calc2, 10)

# ______________________________________________________________________
# ЛЯМБДА

# def sum(x, y):
#     return x+y

# #f = lambda q, w: q+w # ФОРМУЛА ЛЯМБДЫ (например)
# #sum = lambda x, y: x+y # то же самое что и def sum

# def mylt(x, y):
#     return x*y

# def calc(op, a, b):
#     print(op(a,b))
#     #

# calc(lambda x, y: x+y ,4,5) # можно лямбду сразу в функцию бросать
# calc(sum,4,5) #- то же самое что и сверху!!!


# sum = lambda x: x+10
# mult = lambda x: x**2
# print(sum(mult(2))) # сначала считает мульт = 4, потом сум = 14








#___________________________________________-
# быстро создавать списки, словари и тд

# lst = []

# for i in range(1, 21):
#     if (i%2 == 0):
#         lst.append(i)

# print(lst) # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# lst1 = [i for i in range(1,21) if i % 2 == 0]  # Аналогично выше
# print(lst1) # [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# # Если надо создать пару каждого из чисел
# lst3 = [(i, i) for i in range(1,21) if i % 2 == 0] # [(2,2), (4,4), (6,6).., (20,20)]

# def f(x):
#     return x**3
# lst4 = [(i,f(i)) for i in range(1,11) if i % 2 == 0] # будет выполняться функция и выводить списком только четные цифры, потом возв в степень, выводиться будет (число, его куб)
# print(lst4) # [(2, 8), (3,27), (4,64)....(10,1000)]

#_________________________________________________________
# В файле хранятся числа, нужно выбрать четные и
# составить список пар (число; квадрат числа).
# Пример:
# 1 2 3 5 8 15 23 38
# Получить:
# [(2, 4), (8, 64), (38, 1444)]


# path = 'hello.txt' #1 2 3 5 8 15 23 38
# f = open(path, 'r')
# data = f.read() + ' ' # искуственно добавляю пробел (для дальнейшего цикла)
# f.close()

# nomb = []

# while data != '': # пока строка не пустая
#     space_pos = data.index(' ') # ищем позицию первого пробела
#     nomb.append(int(data[:space_pos])) #превращаем в число то ЧТО ДО ПРОБЕЛА и добавляю в список
#     data = data[space_pos+1:] # "удаляем то что прочитано")
   
# out = []
# for e in nomb: # проходимся по элементам в списке из цифр
#     if not e % 2: #  то же самое что e%2 != 0
#         out.append((e, e**2)) # добляем в список вывод (число, число в квадр)
# print (out) # [(2, 4), (8,64), (38, 1444)]



# СДЕЛАЕМ ТО ЖЕ САМОЕ НО КРАСИВО(СТР 81)__________________________________

# def sel_num(f, col): # принммает функцию ф и набор данных кол
#     return [f(x) for x in col] # возвращает список с примененной ф-ей

# def where(f, col):
#     return [x for x in col if f(x)] # возвращает список с условием от функции

# data1 = '1 2 3 5 8 15 23 38'.split() 
# #print(data1) # ['1', '2', '3', '5', '8', '15', '23', '38']

# res = sel_num(int, data1) # наша функция принимает аргументом !!!! ФУНКЦИЮ ИНТ!!!!, и список дата1
# #print(res) # [1, 2, 3, 5, 8, 15, 23, 38]

# res = where(lambda x: not x %2, res) # потому что ф-я where имеет два арг (ф-я , список). Здесь ф-я - lambda, а список(кол) - res
# #print(res) # [2, 8, 38]

# res = sel_num(lambda x: (x, x**2), res)
# print(res) # [(2, 4), (8, 64), (38, 1444)]


#______________________________________________________________
#MAP то же самое что и селект  (нами созданная выше)
# map передает на вход функцию, кот надо применить к списку
# Функция map() применяет указанную функцию к
# каждому элементу итерируемого объекта и
# возвращает итератор с новыми объектами.

# li = [x for x in range(1,10)]
# print (li) # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# li = list(map(lambda x: x+10, li)) # применили ф-ю мэп, кот принимаем на список lil (увеличиваем на 10 каждый эл-т)
# # list применяем чтобы преобраховать преобразованную строку в СПИСОК. Если просто оставить мэп - оно не выведется
# print (li) # [11, 12, 13, 14, 15, 16, 17, 18, 19]


# data2 = input().split() # введение списка через ПРОБЕЛ 
# data3 = list(map(int,data2))
# print(data3)

# можно записать так:
#data3 = list(map(int,input().split())) # сразу преобразовывает введенные с клавиатуры данные в список чисел


#_____________________________________________________________________________________________
# Фильтр - то же самое что и наша ф-я вере(выше что мы создали)
# Функция filter() применяет указанную функцию к
# каждому элементу итерируемого объекта и
# возвращает итератор с теми объектами, для
# которых функция вернула True.
# f(x) ⇒ x - чётное
# filter(f, [ 1, 2, 3, 4,5])
#  ↓
#  [ 2, 4 ]
# Нельзя пройтись дважды

# data5 = [x for x in range(5)]
# print(data5) # [0, 1, 2, 3, 4]
# res = list(filter(lambda x: not x % 2, data5))
# print(res) # [0, 2, 4]


# СДЕЛАЕМ Ту ЖЕ САМУЮ ЗАДАЧУ НО ЕЩЕ ПИЗЖЕ (СТР 81)__________________________________________________


# data1 = '1 2 3 5 8 15 23 38'.split() 
# #print(data1) # ['1', '2', '3', '5', '8', '15', '23', '38']

# res = map(int, data1) # наша функция принимает аргументом !!!! ФУНКЦИЮ ИНТ!!!!, и список дата1
# #print(res) # [1, 2, 3, 5, 8, 15, 23, 38]

# res = filter(lambda x: not x %2, res) # потому что ф-я where имеет два арг (ф-я , список). Здесь ф-я - lambda, а список(кол) - res
# #print(res) # [2, 8, 38]

# res = list(map(lambda x: (x, x**2), res))
# print(res) # [(2, 4), (8, 64), (38, 1444)]


#_____________________________________________________________________
# Функция zip
# ДЕЛАЕТ КОРТЕЖИ
# Функция zip() применяется к набору итерируемых
# объектов и возвращает итератор с кортежами из
# элементов входных данных.
# Количество элементов в результате равно минимальному количеству элементов входного набора
# zip ([1, 2, 3], [ ‘о‘, ‘д‘, ‘т‘], [‘f’,’s’,’t’])
#  ↓
# [(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')]
# Нельзя пройтись дважды


# users = ['u1','u2,', 'u3', 'u4', 'u5', 'u6']
# ids = [1, 2, 3, 4, 5, 6]
# salary = [111, 222, 333]

# data = list(zip(users, ids)) 
# print(data) # [('u1', 1), ('u2', 2), ('u3', 3), ('u4', 4), ('u5', 5), ('u6', 6)]

# data = list(zip(users, ids, salary)) # возьмет минимальный список и сделает столько кортежей сколько в миним списке элементов
# print(data) # [('u1', 1, 111), ('u2', 2,222), ('u3', 3,333)]

# # Если требуется учесть все значения из самой длинной, то следует использовать функцию zip_longest из модуля itertools:
# import itertools
# data = list(itertools.zip_longest(users, ids, salary)) 
# print(data) # [('u1', 1, 111), ('u2', 2,222), ('u3', 3,333), ('u4', 4, None), ('u5', 5, None), ('u6', 6, None)]

# # Как мы видим, если элемента не хватает, то по-умолчанию подставляется объект None. 
# # Можно указать свой вариант заполнения:
# data = list(itertools.zip_longest(users, ids, salary,  fillvalue=0)) 
# print(data) # [('u1', 1, 111), ('u2', 2, 222), ('u3', 3, 333), ('u4', 4, 0), ('u5', 5, 0), ('u6', 6, 0)]


#_____________________________________________________________________
# Функция enumerate
# Функция enumerate() применяется к итерируемому
# объекту и возвращает новый итератор с кортежами
# из индекса и элементов входных данных.
# enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго'])
#  ↓
# [(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')]
# Нельзя пройтись дважды

# users = ['u1','u2,', 'u3', 'u4', 'u5', 'u6']


# data = list(enumerate(users)) 
# print(data) # [(1, 'u1'), (2, 'u2'), (3, 'u3'), (4, 'u4'), (5, 'u5'), (6, 'u6')]
